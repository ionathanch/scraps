module cedille.

{- Quant.       Abstract.    Appl.
   ---------    ---------    -----
   Î  x: ğ’Œ. ğ’Œ    Î» X: ğ’Œ. U    T Â·U
   Î  x: T. ğ’Œ    Î» x: T. U    T  e
   âˆ€ X: ğ’Œ. U    Î› X: ğ’Œ. e    t Â·U
   âˆ€ x: T. U    Î› x: T. e    t -e
   Î  x: T. U    Î» x: T. e    t  e -}

-- Declare type with kind
Unit â—‚ â˜…
= âˆ€ X: â˜…. X â” X.

-- Declare term with type
unit : Unit
= Î› X. Î» x. x.

-- Local definitions
true : âˆ€ X: â˜…. X â” X â” X
= Î› X. Î» x.
  -- Erased definition
  {Y: â˜… = X} - Î» y: Y. x.
false : âˆ€ X: â˜…. X â” X â” X
= Î› X. Î» x.
  -- Non-erased definition
  -- Ï‡ T - t asserts t has type T
  [id = Ï‡ (X â” X) - Î» y. y] - id.

-- Trivial equality proof
refl : âˆ€ X: â˜…. âˆ€ x: X. {x â‰ƒ x}
= Î› X. Î› x. Î².

-- Rewriting via an equality
-- Given a goal type T and an equality p: {e â‰ƒ e'},
-- Ï p - u will rewrite T containing e to T' containing e'
-- in place of e, proving T' with u.
-- The term e of a trivial reflexive proof {e â‰ƒ e}
-- can be specified using Î²<e>.
sym : âˆ€ X: â˜…. âˆ€ x: X. âˆ€ y: X. {x â‰ƒ y} â” {y â‰ƒ x}
= Î› X. Î› x. Î› y. Î» p. Ï p - Î²<y>.

-- Equality with explicit erasure term
-- The erasure of an equality proof Î²{|t|} is t;
-- since the erasure of equalities could be anything,
-- the induction hypothesis must cover all erasures.
-- Note the missing type argument of d that was inferred.
J : âˆ€ X: â˜…. âˆ€ x: X. âˆ€ P: (Î  y: X. {x â‰ƒ y} â” â˜…).
    Î  d: âˆ€ T: â˜…. âˆ€ t: T. P x Î²{|t|}.
    âˆ€ y: X. âˆ€ p: {x â‰ƒ y}. P y p
= Î› X. Î› x. Î› P. Î» d. Î› y. Î› p. Ï (sym -x -y p) - d -p.

-- Subst via J with automatic motive inference
-- In the below where the Î¸ term is, the desired type is P x â” P y.
-- We wish to use J to prove this, and J requires a motive P'.
-- Î¸<y p> then abstracts the desired type over these variables,
-- creating the motive (Î» y: X. Î» p: {x â‰ƒ y}. P x â” P y) (p is unused),
-- then applies the motive to (J -x).
-- Without Î¸, this would be written as J -x Â·P' (Î› T. Î› t. Î» px. px) -y -p,
-- which would be a lot more tedious to write with P' explicitly stated,
-- especially since the abstracted types X and {x â‰ƒ y}
-- syntactically need to be written out in full.
subst : âˆ€ X: â˜…. âˆ€ x: X. âˆ€ y: X. âˆ€ P: X â” â˜…. âˆ€ p: {x â‰ƒ y}. P x â” P y
= Î› X. Î› x. Î› y. Î› P. Î› p. Î¸<y p> (J -x) (Î› T. Î› t. Î» px. px) -y -p.

-- Casting via an equality
-- Given terms e: T, e', and equality p: {e â‰ƒ e'},
-- Ï† p - e {|e'|} erases to e' but has type T.
Omega : {unit â‰ƒ Î» x. x x} â¾ Unit
= Î› p. [omega = Ï† p - unit {|Î» x. x x|}] - omega omega.

-- Ex falso quodlibet
-- Given an equality p: {e â‰ƒ e'} of BÃ¶hm-separable terms,
-- i.e. terms with distinct closed head-normal forms,
-- Î´ - p can be assigned any type (although it erases to Î» x. x).
-- Then Ï† can be used to construct an X that erases to any term;
-- in the below example it erases to p, just for fun.
absurd : {true â‰ƒ false} â” âˆ€ X: â˜…. X
= Î» p. [void: âˆ€ X: â˜…. X = Î´ - p] -
Î› X. Ï† (void Â·{void â‰ƒ p}) - (void Â·X) {|p|}.

-- Declaring a datatype
-- Parameters are elided in all recursive references.
data Acc (X: â˜…) (R: X â” X â” â˜…) : X â” â˜… =
| acc : âˆ€ x: X. (âˆ€ y: X. R y x â” Acc y) â” Acc x.

-- Case destruction with motive
-- Given a construction c, Ïƒ c @P { | C aâ€¦ â” e } deconstructs c
-- into a constructor C and arguments aâ€¦, producing e
-- (where aâ€¦ may be types Â·X or implicits -x, but not parameters)
-- with optional explicit motive P abstracting over indices and target.
-- Supposing inductive I and P = Î» iâ€¦. Î» x. P', in Coq this would be
-- case c as x in I _â€¦ iâ€¦ return P' of | C aâ€¦ â” e end.
accessible : âˆ€ X: â˜…. âˆ€ R: X â” X â” â˜….
             âˆ€ x: X. âˆ€ y: X. R y x â” Acc Â·X Â·R x â” Acc Â·X Â·R y
= Î› X. Î› R. Î› x. Î› y. Î» r. Î» accx.
Ïƒ accx @(Î» x': X. Î» accx': Acc Â·X Â·R x'. {x' â‰ƒ x} â” Acc Â·X Â·R y) {
| acc -x accy â” Î» p. accy -y (Ï p - r)
} Î²<x>.
-- Note that destructing something with an index doesn't unify
-- the index outside of the destruction and inside of it,
-- so using the convoy pattern may be necessary.

-- Well-founded induction
-- If all X are accessible and the predicate P holding for all y R x
-- means that it holds for x, then P holds for all x.
-- Given a construction c, Î¼ f. c @P { | C aâ€¦ â” e } is a fixed point
-- recurring on c, again with optional explicit motive P.
-- Supposing inductive I, in Coq this would be an applied fixpoint
-- (fix f (x: I) : P x := case x of | C aâ€¦ â” e end) c
-- (omitting inductive parameters and indices).
-- Notably, the type of f abstracts over the indices as well.
wfind : âˆ€ X: â˜…. âˆ€ R: X â” X â” â˜…. (âˆ€ x: X. Acc Â·X Â·R x) â”
        âˆ€ P: X â” â˜…. (âˆ€ x: X. (âˆ€ y: X. R y x â” P y) â” P x) â”
        âˆ€ x: X. P x
= Î› X. Î› R. Î» accessible. Î› P. Î» ih. Î› x.
Î¼ wfind. (accessible -x) @(Î» x: X. Î» accx: Acc Â·X Â·R x. P x) {
| acc -x accy â” ih -x (Î› y. Î» r. wfind -y (accy -y r))
}.
